{"version":3,"sources":["Paragon.js"],"names":["root","factory","define","amd","module","exports","require","Paragon","signals","this","jssig","merge","dest","src","k","mkprop","name","sig","val","hasOwnProperty","pk","get","value","undefined","set","nv","prev","alreadychanged","call","dispatch","changed","enumerable","link","self","source","dests","add","model","props","sigs","magicemittersarg","Signal","Object","defineProperties","create","spec","parent","ParagonModel","emitters","apply","arguments","prototype","TypeError","constructor","d","depends","Array","isArray","i","length","preventExtensions"],"mappings":"CAuBC,SAASA,EAAMC,GACf,YAEqB,mBAAVC,SAAwBA,OAAOC,IACzCD,QAAQ,cAAeD,GACI,gBAAVG,SAAsBA,OAAOC,QAC9CD,OAAOC,QAAUJ,EAChBK,QAAQ,YAGTN,EAAKO,QAAUN,EAAQO,UAEvBC,KAAM,SAAwBC,GAC/B,YAOA,SAASC,GAAMC,EAAMC,GACpB,IAAK,GAAIC,KAAKD,GACQ,gBAAVA,GAAIC,IAAoC,gBAAXF,GAAKE,GAC5CH,EAAMC,EAAKE,GAAID,EAAIC,IAEnBF,EAAKE,GAAKD,EAAIC,GAiBjB,QAASC,GAAOC,EAAMC,GAErB,GAAIC,GAAMD,EAAIE,eAAe,SACzBC,EAAK,mBAAmBJ,EACxBK,EAAMJ,EAAII,MAAMH,EACA,WAAW,MAAOT,MAAKU,eAAeC,GAAIX,KAAKW,GAAIH,EAAIK,OACtDC,QACjBC,EAAMP,EAAIO,MAAMN,EAAI,SAASO,GAAIhB,KAAKW,GAAMK,GAAIF,OAEpD,QACCF,IAAKA,EACLG,IAAKA,GAAO,SAA0BN,GACrC,GAAIQ,GAAOjB,KAAKO,GAGZhB,GAAQ2B,CACR3B,KAAM2B,MACVA,EAAeX,GAAQ,EAEvBQ,EAAII,KAAKnB,KAAMS,GAGfT,KAAKO,EAAK,WAAWa,SAASX,EAAKF,EAAMU,EAAMjB,MAG3CT,IACHS,KAAKqB,QAAQD,SAASX,EAAKF,EAAMU,EAAMjB,MACvCkB,GAAiB,IAGnBI,YAAY,GAMd,QAASC,GAAKC,EAAMC,EAAQC,GAC3BF,EAAKC,EAAO,WAAWE,IAAI,SAASlB,EAAKF,EAAMU,EAAMW,GACpD,IAAK,GAAIvB,KAAKqB,GACRR,EAAeb,KACnBa,EAAeb,EAAE,WAAa,EAC9BmB,EAAKnB,EAAE,WAAWe,SAASX,EAAKJ,EAAGY,EAAMW,MAY7C,QAAS9B,KACR,GAAI+B,MACAC,EAAOC,CACX,KAAK,GAAI1B,KAAKyB,GACb9B,KAAKK,EAAE,WAAa,GAAIJ,GAAM+B,OAC9BT,EAAKvB,KAAMK,EAAGyB,EAAKzB,GAGpB4B,QAAOC,iBAAiBlC,KAAM6B,GAE9BE,KAtED,GAAIb,IAAiB,EAwDjBa,IA8EJ,OA9DAE,QAAOC,iBAAiBpC,GAqBvBqC,QACCtB,MAAO,SAAwBuB,EAAMC,GA2BpC,QAASC,KACRpC,EAAM6B,EAAkBQ,GACxBF,EAAOG,MAAMxC,KAAMyC,WAzBpB,GAHAL,EAASA,MACTC,EAASA,GAAUvC,IAEbmC,OAAOE,OAAOE,EAAOK,oBAAsB5C,IAChD,KAAM,IAAI6C,WAAU,mCAErB,IAAIJ,IAAY,GAAG,GACfV,GACHe,aAAgB/B,MAAQyB,GAGzB,KAAK,GAAIjC,KAAK+B,GACS,gBAAXA,GAAK/B,KAAgB+B,EAAK/B,IAAMQ,MAAMuB,EAAK/B,KACtDwB,EAAMxB,GAAKC,EAAOD,EAAG+B,EAAK/B,IAC1BkC,EAASlC,KAGV,KAAK,GAAIA,KAAK+B,GAAM,CACnB,GAAIS,GAAIT,EAAK/B,GAAGyC,OAChB,IAAIC,MAAMC,QAAQH,GACjB,IAAK,GAAII,GAAIJ,EAAEK,OAAQD,KACtBV,EAASM,EAAEI,IAAI5C,GAAK,EAWvB,MAFAiC,GAAaI,UAAYT,OAAOE,OAAOE,EAAOK,UAAWb,GAElDS,MAIVL,OAAOkB,kBAAkBrD,GACzBmC,OAAOkB,kBAAkBrD,EAAQ4C,WAE1B5C","sourcesContent":["// Copyright 2013-2014 Kevin Cox\n\n/*******************************************************************************\n*                                                                              *\n*  This software is provided 'as-is', without any express or implied           *\n*  warranty. In no event will the authors be held liable for any damages       *\n*  arising from the use of this software.                                      *\n*                                                                              *\n*  Permission is granted to anyone to use this software for any purpose,       *\n*  including commercial applications, and to alter it and redistribute it      *\n*  freely, subject to the following restrictions:                              *\n*                                                                              *\n*  1. The origin of this software must not be misrepresented; you must not     *\n*     claim that you wrote the original software. If you use this software in  *\n*     a product, an acknowledgment in the product documentation would be       *\n*     appreciated but is not required.                                         *\n*                                                                              *\n*  2. Altered source versions must be plainly marked as such, and must not be  *\n*     misrepresented as being the original software.                           *\n*                                                                              *\n*  3. This notice may not be removed or altered from any source distribution.  *\n*                                                                              *\n*******************************************************************************/\n+function(root, factory){\n\t\"use strict\";\n\t\n\tif (typeof define == \"function\" && define.amd) { // AMD\n\t\tdefine([\"jssignals1\"], factory);\n\t} else if (typeof module == \"object\" && module.exports) { // Node\n\t\tmodule.exports = factory(\n\t\t\trequire(\"signals\")\n\t\t);\n\t} else {\n\t\troot.Paragon = factory(signals);\n\t}\n}(this, function ParagonFactory(jssig){\n\t\"use strict\";\n\t\n\t/** merge src into dest.\n\t * \n\t * A deep merging function.  There must be no null values.  dest is\n\t * overwritten in case of conflicts.\n\t */\n\tfunction merge(dest, src) {\n\t\tfor (var k in src) {\n\t\t\tif (typeof src[k] == \"object\" && typeof dest[k] == \"object\")\n\t\t\t\tmerge(dest[k], src[k]);\n\t\t\telse\n\t\t\t\tdest[k] = src[k];\n\t\t}\n\t}\n\t\n\t/** Single change map.\n\t * \n\t * This is used so that change events don't keep bouncing around computed\n\t * properties.  It will be false when outside of an update or a set of\n\t * properties that have been updated already.\n\t */\n\tvar alreadychanged = false;\n\t\n\t/** Create a property description.\n\t * \n\t * Creates a description using the spec in sig.  This description will be\n\t * passed to Object.defineProperty.\n\t */\n\tfunction mkprop(name, sig) {\n\t\t//console.log(\"mkprop\", name, sig);\n\t\tvar val = sig.hasOwnProperty(\"value\");\n\t\tvar pk = \"_paragonPrivate_\"+name;\n\t\tvar get = sig.get||(val?\n\t\t                    function(){return this.hasOwnProperty(pk)?this[pk]:sig.value}\n\t\t                    :undefined);\n\t\tvar set = sig.set||(val?function(nv){this[pk] = nv}:undefined);\n\t\t\n\t\treturn {\n\t\t\tget: get,\n\t\t\tset: set && function paragonmodel_set(val){\n\t\t\t\tvar prev = this[name];\n\t\t\t\t\n\t\t\t\t// Set up a signal \"session\".\n\t\t\t\tvar root = !alreadychanged;\n\t\t\t\tif (root) alreadychanged = {};\n\t\t\t\talreadychanged[name] = 1;\n\t\t\t\t\n\t\t\t\tset.call(this, val);\n\t\t\t\t// console.log(\"Model changed\", val, name, prev, this);\n\t\t\t\t\n\t\t\t\tthis[name+\"changed\"].dispatch(val, name, prev, this);\n\t\t\t\t\n\t\t\t\t// If we are the root clean up.\n\t\t\t\tif (root) {\n\t\t\t\t\tthis.changed.dispatch(val, name, prev, this);\n\t\t\t\t\talreadychanged = false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tenumerable: true,\n\t\t};\n\t}\n\t\n\t/** link a dependent property to its source.\n\t */\n\tfunction link(self, source, dests) {\n\t\tself[source+\"changed\"].add(function(val, name, prev, model){\n\t\t\tfor (var k in dests) {\n\t\t\t\tif (!alreadychanged[k]) {\n\t\t\t\t\talreadychanged[k+\"changed\"] = 1;\n\t\t\t\t\tself[k+\"changed\"].dispatch(val, k, prev, model);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\t\n\t/** Used to pass the dependency map down the constructors.\n\t */\n\tvar magicemittersarg = {};\n\t\n\t/** The Paragon base class.\n\t */\n\tfunction Paragon(){\n\t\tvar props = {};\n\t\tvar sigs = magicemittersarg;\n\t\tfor (var k in sigs) {\n\t\t\tthis[k+\"changed\"] = new jssig.Signal();\n\t\t\tlink(this, k, sigs[k]);\n\t\t}\n\t\t\n\t\tObject.defineProperties(this, props);\n\t\t\n\t\tmagicemittersarg = {};\n\t}\n\tObject.defineProperties(Paragon, {\n\t\t/** Create a Paragon Model.\n\t\t * \n\t\t * The first argument is a spec.  It is an object consisting of a\n\t\t * property for each property to create on the model.  The value for\n\t\t * each property is an object with the following keys.\n\t\t * \n\t\t * - value: If present this is used as the initial value of the property.\n\t\t * - get: If value is not provided this is used as a getter for the\n\t\t *        property.\n\t\t * - set: If value is not provided this is used as the setter for the\n\t\t *        property.\n\t\t * - depends: If present it is an array of properties that this computed\n\t\t *            property depends on.\n\t\t * \n\t\t * The second argument is options and specifies the parent class.  If\n\t\t * not provided this defaults to Paragon.  Please note that this class\n\t\t * **must** be a descendant of Paragon.\n\t\t * \n\t\t * Returns a class.\n\t\t */\n\t\tcreate: {\n\t\t\tvalue: function Paragon_create(spec, parent){\n\t\t\t\tspec   = spec   || {};\n\t\t\t\tparent = parent || Paragon;\n\t\t\t\t\n\t\t\t\tif (!(Object.create(parent.prototype) instanceof Paragon))\n\t\t\t\t\tthrow new TypeError(\"Parent must inherit from Paragon\");\n\t\t\t\t\n\t\t\t\tvar emitters = {\"\":1};\n\t\t\t\tvar props = {\n\t\t\t\t\t\"constructor\": {\"value\":ParagonModel},\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tfor (var k in spec) {\n\t\t\t\t\tif (typeof spec[k] != \"object\") spec[k] = {value:spec[k]};\n\t\t\t\t\tprops[k] = mkprop(k, spec[k]);\n\t\t\t\t\temitters[k] = {};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (var k in spec) {\n\t\t\t\t\tvar d = spec[k].depends;\n\t\t\t\t\tif (Array.isArray(d)) {\n\t\t\t\t\t\tfor (var i = d.length; i--; ) {\n\t\t\t\t\t\t\temitters[d[i]][k] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction ParagonModel(){\n\t\t\t\t\tmerge(magicemittersarg, emitters);\n\t\t\t\t\tparent.apply(this, arguments);\n\t\t\t\t}\n\t\t\t\tParagonModel.prototype = Object.create(parent.prototype, props);\n\t\t\t\t\n\t\t\t\treturn ParagonModel;\n\t\t\t},\n\t\t},\n\t});\n\tObject.preventExtensions(Paragon);\n\tObject.preventExtensions(Paragon.prototype);\n\t\n\treturn Paragon;\n});\n"]}