{"version":3,"sources":["url.js"],"names":["array","regex","noslash","self","get","q","opt","o","c","split","i","length","d","indexOf","k","v","substr","decodeURIComponent","ind","inds","curo","curk","match","index","unshift","some","Array","isArray","buildget","data","prefix","itms","ek","encodeURIComponent","push","toString","join","parse","url","md","r","scheme","user","pass","host","port","path","query","hash","build","define","module","window"],"mappings":"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","sourcesContent":["// Copyright 2013-2014 Kevin Cox\n\n/*******************************************************************************\n*                                                                              *\n*  This software is provided 'as-is', without any express or implied           *\n*  warranty. In no event will the authors be held liable for any damages       *\n*  arising from the use of this software.                                      *\n*                                                                              *\n*  Permission is granted to anyone to use this software for any purpose,       *\n*  including commercial applications, and to alter it and redistribute it      *\n*  freely, subject to the following restrictions:                              *\n*                                                                              *\n*  1. The origin of this software must not be misrepresented; you must not     *\n*     claim that you wrote the original software. If you use this software in  *\n*     a product, an acknowledgment in the product documentation would be       *\n*     appreciated but is not required.                                         *\n*                                                                              *\n*  2. Altered source versions must be plainly marked as such, and must not be  *\n*     misrepresented as being the original software.                           *\n*                                                                              *\n*  3. This notice may not be removed or altered from any source distribution.  *\n*                                                                              *\n*******************************************************************************/\n\n+function(){\n\"use strict\";\n\nvar array = /\\[([^\\[]*)\\]$/;\n\n/// URL Regex.\n/**\n * This regex splits the URL into parts.  The capture groups catch the important\n * bits.\n * \n * Each section is optional, so to work on any part find the correct top level\n * `(...)?` and mess around with it.\n */\nvar regex = /^(?:([a-z]*):)?(?:\\/\\/)?(?:([^:@]*)(?::([^@]*))?@)?([0-9a-z-._]+)?(?::([0-9]*))?(\\/[^?#]*)?(?:\\?([^#]*))?(?:#(.*))?$/i;\n//               1 - scheme              2 - user    3 = pass    4 - host           5 - port  6 - path        7 - query    8 - hash\n\nvar noslash = [\"mailto\",\"bitcoin\"];\n\nvar self = {\n\t/** Parse a query string.\n\t *\n\t * This function parses a query string (sometimes called the search\n\t * string).  It takes a query string and returns a map of the results.\n\t *\n\t * Keys are considered to be everything up to the first '=' and values are\n\t * everything afterwords.  Since URL-decoding is done after parsing, keys\n\t * and values can have any values, however, '=' have to be encoded in keys\n\t * while '?' and '&' have to be encoded anywhere (as they delimit the\n\t * kv-pairs).\n\t *\n\t * Keys and values will always be strings, except if there is a key with no\n\t * '=' in which case it will be considered a flag and will be set to true.\n\t * Later values will override earlier values.\n\t *\n\t * Array keys are also supported.  By default keys in the form of `name[i]`\n\t * will be returned like that as strings.  However, if you set the `array`\n\t * flag in the options object they will be parsed into arrays.  Note that\n\t * although the object returned is an `Array` object all keys will be\n\t * written to it.  This means that if you have a key such as `k[forEach]`\n\t * it will overwrite the `forEach` function on that array.  Also note that\n\t * string properties always take precedence over array properties,\n\t * irrespective of where they are in the query string.\n\t *\n\t *   url.get(\"array[1]=test&array[foo]=bar\",{array:true}).array[1]  === \"test\"\n\t *   url.get(\"array[1]=test&array[foo]=bar\",{array:true}).array.foo === \"bar\"\n\t *   url.get(\"array=notanarray&array[0]=1\",{array:true}).array      === \"notanarray\"\n\t *\n\t * If array parsing is enabled keys in the form of `name[]` will\n\t * automatically be given the next available index.  Note that this can be\n\t * overwritten with later values in the query string.  For this reason is\n\t * is best not to mix the two formats, although it is safe (and often\n\t * useful) to add an automatic index argument to the end of a query string.\n\t *\n\t *   url.get(\"a[]=0&a[]=1&a[0]=2\", {array:true})  -> {a:[\"2\",\"1\"]};\n\t *   url.get(\"a[0]=0&a[1]=1&a[]=2\", {array:true}) -> {a:[\"0\",\"1\",\"2\"]};\n\t *\n\t * @param{string} q The query string (the part after the '?').\n\t * @param{{full:boolean,array:boolean}=} opt Options.\n\t *\n\t * - full: If set `q` will be treated as a full url and `q` will be built.\n\t *   by calling #parse to retrieve the query portion.\n\t * - array: If set keys in the form of `key[i]` will be treated\n\t *   as arrays/maps.\n\t *\n\t * @return{!Object.<string, string|Array>} The parsed result.\n\t */\n\t\"get\": function(q, opt){\n\t\tq = q || \"\";\n\t\tif ( typeof opt          == \"undefined\" ) opt = {};\n\t\tif ( typeof opt[\"full\"]  == \"undefined\" ) opt[\"full\"] = false;\n\t\tif ( typeof opt[\"array\"] == \"undefined\" ) opt[\"array\"] = false;\n\t\t\n\t\tif ( opt[\"full\"] === true )\n\t\t{\n\t\t\tq = self[\"parse\"](q, {\"get\":false})[\"query\"] || \"\";\n\t\t}\n\t\t\n\t\tvar o = {};\n\t\t\n\t\tvar c = q.split(\"&\");\n\t\tfor (var i = 0; i < c.length; i++)\n\t\t{\n\t\t\tif (!c[i].length) continue;\n\t\t\t\n\t\t\tvar d = c[i].indexOf(\"=\");\n\t\t\tvar k = c[i], v = true;\n\t\t\tif ( d >= 0 )\n\t\t\t{\n\t\t\t\tk = c[i].substr(0, d);\n\t\t\t\tv = c[i].substr(d+1);\n\t\t\t\t\n\t\t\t\tv = decodeURIComponent(v);\n\t\t\t}\n\t\t\t\n\t\t\tif (opt[\"array\"])\n\t\t\t{\n\t\t\t\tvar inds = [];\n\t\t\t\tvar ind;\n\t\t\t\tvar curo = o;\n\t\t\t\tvar curk = k;\n\t\t\t\twhile (ind = curk.match(array)) // Array!\n\t\t\t\t{\n\t\t\t\t\tcurk = curk.substr(0, ind.index);\n\t\t\t\t\tinds.unshift(decodeURIComponent(ind[1]));\n\t\t\t\t}\n\t\t\t\tcurk = decodeURIComponent(curk);\n\t\t\t\tif (inds.some(function(i)\n\t\t\t\t{\n\t\t\t\t\tif ( typeof curo[curk] == \"undefined\" ) curo[curk] = [];\n\t\t\t\t\tif (!Array.isArray(curo[curk]))\n\t\t\t\t\t{\n\t\t\t\t\t\t//console.log(\"url.get: Array property \"+curk+\" already exists as string!\");\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcuro = curo[curk];\n\t\t\t\t\t\n\t\t\t\t\tif ( i === \"\" ) i = curo.length;\n\t\t\t\t\t\n\t\t\t\t\tcurk = i;\n\t\t\t\t})) continue;\n\t\t\t\tcuro[curk] = v;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tk = decodeURIComponent(k);\n\t\t\t\n\t\t\t//typeof o[k] == \"undefined\" || console.log(\"Property \"+k+\" already exists!\");\n\t\t\to[k] = v;\n\t\t}\n\t\t\n\t\treturn o;\n\t},\n\t\n\t/** Build a get query from an object.\n\t *\n\t * This constructs a query string from the kv pairs in `data`.  Calling\n\t * #get on the string returned should return an object identical to the one\n\t * passed in except all non-boolean scalar types become strings and all\n\t * object types become arrays (non-integer keys are still present, see\n\t * #get's documentation for more details).\n\t *\n\t * This always uses array syntax for describing arrays.  If you want to\n\t * serialize them differently (like having the value be a JSON array and\n\t * have a plain key) you will need to do that before passing it in.\n\t *\n\t * All keys and values are supported (binary data anyone?) as they are\n\t * properly URL-encoded and #get properly decodes.\n\t *\n\t * @param{Object} data The kv pairs.\n\t * @param{string} prefix The properly encoded array key to put the\n\t *   properties.  Mainly intended for internal use.\n\t * @return{string} A URL-safe string.\n\t */\n\t\"buildget\": function(data, prefix){\n\t\tvar itms = [];\n\t\tfor ( var k in data )\n\t\t{\n\t\t\tvar ek = encodeURIComponent(k);\n\t\t\tif ( typeof prefix != \"undefined\" )\n\t\t\t\tek = prefix+\"[\"+ek+\"]\";\n\t\t\t\n\t\t\tvar v = data[k];\n\t\t\t\n\t\t\tswitch (typeof v)\n\t\t\t{\n\t\t\t\tcase 'boolean':\n\t\t\t\t\tif(v) itms.push(ek);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'number':\n\t\t\t\t\tv = v.toString();\n\t\t\t\tcase 'string':\n\t\t\t\t\titms.push(ek+\"=\"+encodeURIComponent(v));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'object':\n\t\t\t\t\titms.push(self[\"buildget\"](v, ek));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn itms.join(\"&\");\n\t},\n\t\n\t/** Parse a URL\n\t * \n\t * This breaks up a URL into components.  It attempts to be very liberal\n\t * and returns the best result in most cases.  This means that you can\n\t * often pass in part of a URL and get correct categories back.  Notably,\n\t * this works for emails and Jabber IDs, as well as adding a '?' to the\n\t * beginning of a string will parse the whole thing as a query string.  If\n\t * an item is not found the property will be undefined.  In some cases an\n\t * empty string will be returned if the surrounding syntax but the actual\n\t * value is empty (example: \"://example.com\" will give a empty string for\n\t * scheme.)  Notably the host name will always be set to something.\n\t * \n\t * Returned properties.\n\t * \n\t * - **scheme:** The url scheme. (ex: \"mailto\" or \"https\")\n\t * - **user:** The username.\n\t * - **pass:** The password.\n\t * - **host:** The hostname. (ex: \"localhost\", \"123.456.7.8\" or \"example.com\")\n\t * - **port:** The port, as a number. (ex: 1337)\n\t * - **path:** The path. (ex: \"/\" or \"/about.html\")\n\t * - **query:** \"The query string. (ex: \"foo=bar&v=17&format=json\")\n\t * - **get:** The query string parsed with get.  If `opt.get` is `false` this\n\t *   will be absent\n\t * - **hash:** The value after the hash. (ex: \"myanchor\")\n\t *   be undefined even if `query` is set.\n\t *\n\t * @param{string} url The URL to parse.\n\t * @param{{get:Object}=} opt Options:\n\t *\n\t * - get: An options argument to be passed to #get or false to not call #get.\n\t *    **DO NOT** set `full`.\n\t *\n\t * @return{!Object} An object with the parsed values.\n\t */\n\t\"parse\": function(url, opt) {\n\t\t\n\t\tif ( typeof opt == \"undefined\" ) opt = {};\n\t\t\n\t\tvar md = url.match(regex) || [];\n\t\t\n\t\tvar r = {\n\t\t\t\"url\":    url,\n\t\t\t\n\t\t\t\"scheme\": md[1],\n\t\t\t\"user\":   md[2],\n\t\t\t\"pass\":   md[3],\n\t\t\t\"host\":   md[4],\n\t\t\t\"port\":   md[5] && +md[5],\n\t\t\t\"path\":   md[6],\n\t\t\t\"query\":  md[7],\n\t\t\t\"hash\":   md[8],\n\t\t};\n\t\t\n\t\tif ( opt.get !== false )\n\t\t\tr[\"get\"] = r[\"query\"] && self[\"get\"](r[\"query\"], opt.get);\n\t\t\n\t\treturn r;\n\t},\n\t\n\t/** Build a URL from components.\n\t * \n\t * This pieces together a url from the properties of the passed in object.\n\t * In general passing the result of `parse()` should return the URL.  There\n\t * may differences in the get string as the keys and values might be more\n\t * encoded then they were originally were.  However, calling `get()` on the\n\t * two values should yield the same result.\n\t * \n\t * Here is how the parameters are used.\n\t * \n\t *  - url: Used only if no other values are provided.  If that is the case\n\t *     `url` will be returned verbatim.\n\t *  - scheme: Used if defined.\n\t *  - user: Used if defined.\n\t *  - pass: Used if defined.\n\t *  - host: Used if defined.\n\t *  - path: Used if defined.\n\t *  - query: Used only if `get` is not provided and non-empty.\n\t *  - get: Used if non-empty.  Passed to #buildget and the result is used\n\t *    as the query string.\n\t *  - hash: Used if defined.\n\t * \n\t * These are the options that are valid on the options object.\n\t * \n\t *  - useemptyget: If truthy, a question mark will be appended for empty get\n\t *    strings.  This notably makes `build()` and `parse()` fully symmetric.\n\t *\n\t * @param{Object} data The pieces of the URL.\n\t * @param{Object} opt Options for building the url.\n\t * @return{string} The URL.\n\t */\n\t\"build\": function(data, opt){\n\t\topt = opt || {};\n\t\t\n\t\tvar r = \"\";\n\t\t\n\t\tif ( typeof data[\"scheme\"] != \"undefined\" )\n\t\t{\n\t\t\tr += data[\"scheme\"];\n\t\t\tr += (noslash.indexOf(data[\"scheme\"])>=0)?\":\":\"://\";\n\t\t}\n\t\tif ( typeof data[\"user\"] != \"undefined\" )\n\t\t{\n\t\t\tr += data[\"user\"];\n\t\t\tif ( typeof data[\"pass\"] == \"undefined\" )\n\t\t\t{\n\t\t\t\tr += \"@\";\n\t\t\t}\n\t\t}\n\t\tif ( typeof data[\"pass\"] != \"undefined\" ) r += \":\" + data[\"pass\"] + \"@\";\n\t\tif ( typeof data[\"host\"] != \"undefined\" ) r += data[\"host\"];\n\t\tif ( typeof data[\"port\"] != \"undefined\" ) r += \":\" + data[\"port\"];\n\t\tif ( typeof data[\"path\"] != \"undefined\" ) r += data[\"path\"];\n\t\t\n\t\tif (opt[\"useemptyget\"])\n\t\t{\n\t\t\tif      ( typeof data[\"get\"]   != \"undefined\" ) r += \"?\" + self[\"buildget\"](data[\"get\"]);\n\t\t\telse if ( typeof data[\"query\"] != \"undefined\" ) r += \"?\" + data[\"query\"];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// If .get use it.  If .get leads to empty, use .query.\n\t\t\tvar q = data[\"get\"] && self[\"buildget\"](data[\"get\"]) || data[\"query\"];\n\t\t\tif (q) r += \"?\" + q;\n\t\t}\n\t\t\n\t\tif ( typeof data[\"hash\"] != \"undefined\" ) r += \"#\" + data[\"hash\"];\n\t\t\n\t\treturn r || data[\"url\"] || \"\";\n\t},\n};\n\nif ( typeof define != \"undefined\" && define[\"amd\"] ) define(self);\nelse if ( typeof module != \"undefined\" ) module['exports'] = self;\nelse window[\"url\"] = self;\n\n}();\n"]}